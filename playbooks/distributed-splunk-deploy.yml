---
# Complete playbook for deploying and configuring a distributed Splunk environment
# Run with: ansible-playbook -i inventory.yml deploy_splunk_distributed_complete.yml --ask-vault-pass

# Phase 1: INSTALLATION
# Step 1: Deploy License Master first
- name: Deploy License Master
  hosts: licensemaster
  pre_tasks:
    - name: Ensure /etc/logrotate.d/syslog exists
      file:
        path: /etc/logrotate.d/syslog
        state: touch
        mode: '0644'
      when: ansible_os_family == 'RedHat'

  become: true
  gather_facts: true
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Step 2: Deploy Deployment Server
- name: Deploy Deployment Server  
  hosts: deploymentserver
  become: true
  gather_facts: true
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Step 3: Deploy Indexers
- name: Deploy Indexers
  hosts: indexer  
  pre_tasks:
    - name: Ensure /etc/logrotate.d/syslog exists
      file:
        path: /etc/logrotate.d/syslog
        state: touch
        mode: '0644'
      when: ansible_os_family == 'RedHat'

  become: true
  gather_facts: true
  serial: 1  # Deploy one at a time for safety
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Step 4: Deploy Search Heads
- name: Deploy Search Heads
  hosts: search
  pre_tasks:
    - name: Ensure /etc/logrotate.d/syslog exists
      file:
        path: /etc/logrotate.d/syslog
        state: touch
        mode: '0644'
      when: ansible_os_family == 'RedHat'

  become: true
  gather_facts: true
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Step 5: Deploy Heavy Forwarders (if any)
- name: Deploy Heavy Forwarders
  hosts: heavyforwarder
  pre_tasks:
    - name: Ensure /etc/logrotate.d/syslog exists
      file:
        path: /etc/logrotate.d/syslog
        state: touch
        mode: '0644'
      when: ansible_os_family == 'RedHat'

  become: true
  gather_facts: true
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Step 6: Deploy Universal Forwarders
- name: Deploy Universal Forwarders
  hosts: uf
  pre_tasks:
    - name: Ensure /etc/logrotate.d/syslog exists
      file:
        path: /etc/logrotate.d/syslog
        state: touch
        mode: '0644'
      when: ansible_os_family == 'RedHat'

  become: true
  gather_facts: true
  serial: 10  # Deploy 10 at a time
  vars:
    deployment_task: check_splunk.yml
  roles:
    - ansible-role-for-splunk

# Phase 2: CONFIGURATION - Monorepo App Deployment with LFS Support
- name: Clone Git Repository with LFS Support
  hosts: all
  gather_facts: false
  become: false
  tags: ["git_operations"]

  tasks:
    - name: Verify git-lfs is available
      command: git lfs version
      register: lfs_check
      changed_when: false
      failed_when: false
      environment:
        PATH: "/usr/local/bin:/usr/bin:/bin:{{ ansible_env.PATH }}"
      delegate_to: localhost  # Add this
      run_once: true          # Add this
      
    - name: Show git-lfs status
      debug:
        msg: "Git LFS status: {{ 'Available' if lfs_check.rc == 0 else 'NOT FOUND - Please install manually: sudo yum install git-lfs && git lfs install' }}"
      environment:
        PATH: "/usr/local/bin:/usr/bin:/bin:{{ ansible_env.PATH }}"
      delegate_to: localhost  # Add this
      run_once: true          # Add this
      
    - name: Fail if git-lfs not available
      fail:
        msg: "git-lfs is required but not found. Please run: sudo yum install git-lfs && git lfs install"
      when: lfs_check.rc != 0
      environment:
        PATH: "/usr/local/bin:/usr/bin:/bin:{{ ansible_env.PATH }}"
      delegate_to: localhost  # Add this
      run_once: true          # Add this

    - name: Remove existing checkout directory
      file:
        path: "{{ monorepo_checkout_dir }}"
        state: absent
      delegate_to: localhost  # Add this
      run_once: true          # Add this

    - name: Clone repository with LFS support
      shell: |
        git lfs clone {{ git_server }}/{{ git_project }}.git {{ monorepo_checkout_dir }}
        cd {{ monorepo_checkout_dir }}
        git checkout {{ git_version }}
      environment:
        GIT_SSH_COMMAND: "ssh -i {{ git_key }} -o StrictHostKeyChecking=no"
        PATH: "/usr/local/bin:/usr/bin:/bin:{{ ansible_env.PATH }}"
      register: clone_result
      delegate_to: localhost  # Add this
      run_once: true          # Add this

    - name: 
      shell: |
        cd {{ monorepo_checkout_dir }}
        echo "Checking for LFS pointer files..."
        
        # Find large files that might be LFS
        find . -name "*.tgz" -o -name "*.exe" -o -name "*.zip" -o -name "*.tar.gz" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
            if [ "$size" -lt 200 ]; then
              echo "WARNING: $file is only $size bytes - might be an LFS pointer"
              head -3 "$file" 2>/dev/null || true
            else
              echo "OK: $file ($size bytes)"
            fi
          fi
        done
        
        echo "LFS verification complete"
      register: lfs_verification
      delegate_to: localhost  # Add this
      run_once: true          # Add this

    - name: Show LFS verification results
      debug:
        msg: "{{ lfs_verification.stdout_lines }}"
      delegate_to: localhost  # Add this
      run_once: true          # Add this

# Alternative: Simpler approach - replace the app deployment section with this

- name: Deploy Apps to Splunk Hosts (Simple Discovery)
  hosts: all
  gather_facts: true
  become: true

  tasks:
    # Step 1: Determine which directories to deploy from based on host type
    - name: Set app directories to deploy for this host
      set_fact:
        app_directories: "{{ base_dirs + specific_dirs }}"
      vars:
        # Everyone gets common apps
        base_dirs: ["common"]
        # Add specific directories based on host group
        specific_dirs: >-
          {{
            (['indexers'] if 'indexer' in group_names else []) +
            (['searchheads'] if 'search' in group_names else []) +
            (['heavy_forwarders'] if 'heavyforwarder' in group_names else []) +
            (['universal_forwarders'] if 'uf' in group_names else []) +
            (['deploymentserver'] if 'deploymentserver' in group_names else []) +
            (['licensemaster'] if 'licensemaster' in group_names else [])
          }}

    - name: Show directories this host will deploy from
      debug:
        msg: "{{ inventory_hostname }} will deploy apps from: {{ app_directories }}"

    # Step 2: Discover all apps in those directories
    - name: Find all apps in relevant directories
      find:
        paths: "{{ monorepo_checkout_dir }}/{{ item }}"
        file_type: directory
        recurse: no
      register: discovered_apps_raw
      loop: "{{ app_directories }}"
      delegate_to: localhost
      become: false
      failed_when: false  # Don't fail if directory doesn't exist

    # Step 3: Build the app list
    - name: Build final app list
      set_fact:
        git_apps: "{{ git_apps | default([]) + [{'name': item.path | basename, 'app_relative_path': item.path | regex_replace('^.*splunk-apps-checkout/', '')}] }}"
      loop: "{{ discovered_apps_raw.results | selectattr('files', 'defined') | map(attribute='files') | flatten }}"

    - name: Show deployment plan for this host
      debug:
        msg: 
          - "Host: {{ inventory_hostname }}"
          - "Groups: {{ group_names }}"
          - "Apps to deploy: {{ git_apps | default([]) | map(attribute='name') | list }}"

    # Step 4: Deploy the apps (same as before)
    - name: Ensure Splunk etc/apps directory exists
      file:
        path: "{{ splunk_home }}/etc/apps"
        state: directory
        owner: "{{ splunk_nix_user }}"
        group: "{{ splunk_nix_group }}"
        mode: '0755'

    - name: Deploy each app
      copy:
        src: "{{ monorepo_checkout_dir }}/{{ item.app_relative_path }}/"
        dest: "{{ splunk_home }}/etc/apps/{{ item.name }}/"
        owner: "{{ splunk_nix_user }}"
        group: "{{ splunk_nix_group }}"
        mode: preserve
        directory_mode: '0755'
        remote_src: no
        follow: yes
      loop: "{{ git_apps | default([]) }}"
      when: git_apps is defined and git_apps | length > 0

    - name: Show final deployment summary
      debug:
        msg: "Deployed {{ git_apps | default([]) | length }} apps to {{ inventory_hostname }}: {{ git_apps | default([]) | map(attribute='name') | list }}"

# Cleanup
#- name: Cleanup Git Repository
#  hosts: localhost
#  gather_facts: false
#  become: false
#  
#  tasks:
#    - name: Clean up temporary checkout directory
#      file:
#        path: "{{ monorepo_checkout_dir }}"
#        state: absent

# Step 8: Configure Deployment Server (server classes, etc.)
- name: Configure Deployment Server
  hosts: deploymentserver
  become: true
  gather_facts: true
  vars:
    deployment_task: configure_serverclass.yml
  roles:
    - ansible-role-for-splunk

# Step 10: Restart All Services to Apply Configurations
- name: Restart All Splunk Services
  hosts: all
  become: true
  gather_facts: false
  tasks:
    - name: Restart Splunk to apply all configurations
      service:
        name: "{{ splunk_service | default('Splunkd') }}"
        state: restarted

    - name: Wait for Splunk to be ready after restart
      wait_for:
        port: "{{ splunkd_port | default(8089) }}"
        state: started
        delay: 30
        timeout: 300

# Phase 3: VERIFICATION
# Step 11: Verify Deployment
- name: Verify Complete Deployment
  hosts: all
  become: true
  gather_facts: false
  tasks:
    - name: Check Splunk status
      command: "{{ splunk_home | default('/opt/splunk') }}/bin/splunk status"
      register: splunk_status
      become_user: "{{ splunk_nix_user | default('splunk') }}"
      
    - name: Display Splunk status
      debug:
        msg: "{{ inventory_hostname }}: {{ splunk_status.stdout }}"

    - name: Check for deployed apps
      find:
        paths: "{{ splunk_home | default('/opt/splunk') }}/etc/apps"
        file_type: directory
      register: deployed_apps
      when: "'uf' not in group_names"  # Skip for UF as they might not have apps yet

    - name: Display deployed apps
      debug:
        msg: "Deployed apps: {{ deployed_apps.files | map(attribute='path') | map('basename') | list }}"
      when: deployed_apps is defined and not deployed_apps.skipped | default(false)

# Step 12: Display Environment Summary
- name: Display Environment Summary
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Show deployment summary
      debug:
        msg:
          - "=== SPLUNK DEPLOYMENT COMPLETE ==="
          - ""
          - "Infrastructure Components:"
          - "  License Master: {{ groups['licensemaster'] | join(', ') if groups['licensemaster'] is defined else 'None' }}"
          - "  Deployment Server: {{ groups['deploymentserver'] | join(', ') if groups['deploymentserver'] is defined else 'None' }}"
          - ""
          - "Data Tier:"
          - "  Indexers: {{ groups['indexer'] | join(', ') if groups['indexer'] is defined else 'None' }}"
          - "  Search Heads: {{ groups['search'] | join(', ') if groups['search'] is defined else 'None' }}"
          - ""
          - "Forwarders:"
          - "  Heavy Forwarders: {{ groups['heavyforwarder'] | join(', ') if groups['heavyforwarder'] is defined else 'None' }}"
          - "  Universal Forwarders: {{ groups['uf'] | length if groups['uf'] is defined else 0 }} hosts"
          - ""
          - "Access URLs:"
          - "{% for host in groups['search'] | default([]) %}  Search Head ({{ host }}): https://{{ hostvars[host]['ansible_host'] | default(host) }}:8000{% endfor %}"
          - "{% for host in groups['licensemaster'] | default([]) %}  License Master ({{ host }}): https://{{ hostvars[host]['ansible_host'] | default(host) }}:8000{% endfor %}"
          - ""
          - "Next Steps:"
          - "1. Verify all services are running"
          - "2. Check deployment server client connections"
          - "3. Verify data flow from forwarders to indexers"
          - "4. Test search head distributed search capabilities"
          - "5. Review SSL certificate deployment"